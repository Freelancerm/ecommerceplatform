# ğŸ“¦ Microservices Architecture Project

The Ecommerce Microservices Project is a comprehensive, scalable, and highly available ecommerce platform built using a microservices architecture. It consists of multiple independent services, each responsible for a specific domain, such as authentication, inventory, orders, and notifications. This project aims to provide a robust, flexible, and maintainable ecommerce solution that can be easily extended and customized to meet the needs of various businesses.

ğŸš€ **Key Features**

*   **Authentication Microservice:**
    *   ğŸ” User authentication using OTP (One-Time Password) via Telegram.
    *   ğŸ”‘ JWT (JSON Web Token) based access and refresh token generation and verification.
    *   ğŸ›¡ï¸ Role-based access control (admin).
    *   ğŸ“± Binding Telegram chat ID to user phone number.
*   **Inventory Microservice:**
    *   ğŸ“¦ CRUD operations for inventory items.
    *   ğŸ”„ Stock reservation and release functionality.
    *   ğŸ“¢ Real-time stock updates via Redis Pub/Sub.
    *   ğŸ”’ Admin-protected endpoints for inventory management.
*   **Order Microservice:** 
    * Handles order management, including creating new orders, executing distributed transactions, and publishing events to notify admins and confirm orders with users.
*   **Notification Microservice:** 
    * Provides real-time notifications to users, including order updates, inventory changes, and other important events.
*   **Catalog Microservice:** 
    * Manages product data, including creating, reading, updating, and deleting products.
*   **API Gateways:** 
    * Exposes RESTful APIs for each microservice, allowing for easy integration with web and mobile applications.
* **Shared Libraries:**
    *   Reusable JWT core library for token management.
*   **Core Functionality:**
    *   Health check endpoints for monitoring service status.
    *   Configuration management using environment variables.
    *   Asynchronous database interactions.

ğŸ› ï¸ **Tech Stack**

*   **Backend:**
    *    Python 3.11+
    *    FastAPI: Web framework for building APIs.
    *    SQLAlchemy: ORM for database interactions.
    *    Redis: In-memory data store for caching and pub/sub.
    *    PyJWT: JSON Web Token implementation.
    *   ï¸ Pydantic: Data validation and settings management.
    *    Pydantic Settings: Load settings from `.env` files.
    *    Python-jose: JWT signing and encryption.
    *    asyncio: For asynchronous programming
    *    contextlib: For defining async context managers
*   **Database:**
    *   ğŸ˜ PostgreSQL (or any SQLAlchemy-supported database)
*   **Other:**
    *   ğŸ“¦ Docker: Containerization (optional, for deployment)
    *   ğŸ“œ .env: Environment variable management
    *   ğŸ§ª pytest: Testing framework (not explicitly shown in summaries, but recommended)

ğŸ“¦ **Getting Started / Setup Instructions**

### Prerequisites

*   Python 3.11+
*   Poetry (recommended) or pip
*   Docker (optional, for running Redis and PostgreSQL)
*   Redis instance
*   PostgreSQL database

### Installation

1.  **Clone the repository:**

    ```bash
    git clone <repository_url>
    cd <repository_name>
    ```

2.  **Set up a virtual environment (recommended):**

    ```bash
    python -m venv venv
    source venv/bin/activate  # On Linux/macOS
    venv\Scripts\activate  # On Windows
    ```

3.  **Install dependencies using Poetry (recommended):**

    ```bash
    poetry install
    ```

    Or, install dependencies using pip:

    ```bash
    pip install -r requirements.txt
    ```

4.  **Configure environment variables:**

    *   Create a `.env` file in each microservice directory (`microservices/auth/src/.env`, `microservices/inventory/src/.env`).
    *   Populate the `.env` files with the necessary configuration values, such as:

        ```
        PROJECT_NAME="Your Project Name"
        DATABASE_URL="postgresql+asyncpg://user:password@host:port/database"
        REDIS_URL="redis://host:port/0"
        ELASTICSEARCH_URL="http://host:port" # Optional
        SECRET_KEY="YourSecretKey"
        ALGORITHM="HS256"
        JWT_SECRET="YourJWTSecret"
        ACCESS_TOKEN_EXPIRE_MINUTES=30
        REFRESH_TOKEN_EXPIRE_MINUTES=60 * 24 * 30  # 30 days
        ```

        Replace the placeholder values with your actual configuration.

### Running Locally

1.  **Start the Redis and PostgreSQL databases (if not already running):**

    *   Using Docker Compose (example):

        ```yaml
        version: "3.8"
        services:
          redis:
            image: "redis:latest"
            ports:
              - "6379:6379"
          db:
            image: postgres:15
            environment:
              POSTGRES_USER: youruser
              POSTGRES_PASSWORD: yourpassword
              POSTGRES_DB: yourdatabase
            ports:
              - "5432:5432"
            volumes:
              - db_data:/var/lib/postgresql/data

        volumes:
          db_data:
        ```

        ```bash
        docker-compose up -d
        ```

2.  **Run the authentication microservice:**

    ```bash
    cd microservices/auth/src
    poetry run uvicorn main:app --reload  # Using Poetry
    # or
    uvicorn main:app --reload # if you have fastapi installed globally
    ```

3.  **Run the inventory microservice:**

    ```bash
    cd microservices/inventory/src
    poetry run uvicorn main:app --reload  # Using Poetry
    # or
    uvicorn main:app --reload # if you have fastapi installed globally
    ```

4.  **Access the APIs:**

    *   Authentication microservice: `http://localhost:8000` (or the port you configured)
    *   Inventory microservice: `http://localhost:8001` (or the port you configured)

ğŸ“‚ **Project Structure**

| Service name:PORT | Description                                                         |
|:------------------|:--------------------------------------------------------------------|
| **Service A :81** |	Catalog/Search Service  Fast reading, search, filters (CQRS Read Model).|
| **Service B :82** |	Inventory Service	CQRS Write Model. |
| **Service C :83** |	Order Service	Saga orcherstrator, manage orders.|
| **Service D :80** |	Auth Service	Authorization,gives JWT token, bind Telegram ID.|
| **Service E :84** |	Notification Service	Centralized sending notification (Telegram Bot).|

```markdown
.
â”œâ”€â”€ microservices
â”‚   â”œâ”€â”€ auth
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth_routes.py
â”‚   â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ tests
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ inventory
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ inventory_routes.py
â”‚   â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ tests
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ order
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ order_routers.py
â”‚   â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ tests
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ notification
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ws.py
â”‚   â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ tests
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ catalog
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ products.py
â”‚   â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config.py
â”‚   â”‚   â”œâ”€â”€ tests
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ requirements.txt
```